\documentclass[11pt]{article}
\usepackage{a4}
\usepackage[utf8]{inputenc}
\usepackage{glossaries}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage[toc,page]{appendix}
\makeglossaries

\newglossaryentry{Gamygdala}
{
	name=Gamygdala,
	description={An emotional engine created to simulate emotions for virtual identities\cite{Gamygdala}.}
}

\newglossaryentry{GOAL}
{
	name=GOAL,
	description={A programming language developed at TU Delft for creating Virtual Humans\cite{GOAL}.}
}

\newglossaryentry{agent}
{
	name=agent,
	description={A virtual identity that uses logical rules to derive the wanted actions and can percept events from the environment. It is AI.}
}

\newglossaryentry{MoSCoW}
{
	name=MoSCoW,
	description={A method used to fill in requirements for a project based on difference in priority regarding the final goal of the project.\cite{MoSCoW}}
}


\title{Final Report}
\author{GROUP: Gamygdala-Integration:\\
	B.L.L. Kreynen, bkreynen, 4331842\\
	M. Spanoghe, mspanoghe, 4331834\\
	R.A.N. Starre, rstarre, 4334620\\
	Y.L. Verhoog, ylverhoog, 4155335\\
	J.H. Wooning, jwooning, 4245318\\
}

\begin{document}
% Title Page
\maketitle
\pagebreak
\tableofcontents
\pagebreak
\section{Abstract}

\clearpage

\section{Introduction}
In this section you can find a brief introduction to the context problem and to the solutions applied by group 3. 
\subsection{Problem description}
The research problem is stated by a company called Tygron. They provide local authorities with a game in which their city is fully simulated. In this game the council members can discuss difficult matters on where to build certain structures. By doing so they gain an understanding of everybody's needs and responsibilities. The main question that rises is the possibility of replacing one of those players with an Artificial Intelligence solution. Since the players of this game mostly interact in an emotional way, as real humans do, these bots should feel emotions too.\par 
This topic is very interesting because it has many applications. Both further research and different industries can profit from this. For this context project the students work in a large group that is subdivided into different smaller groups each with specific tasks. In total there are 4 groups of 5 students that work together. Together the whole group will make a proof of concept by creating a game in the Tygron engine\cite{Tygron}, creating an interface between the Tygron engine and \gls{GOAL} and creating both a plug-in and an integration of the \gls{Gamygdala} emotional engine in GOAL. The specific task of this subgroup is to provide the group that will create an agent with an integration of Gamygdala in GOAL. It is not our task to implement the engine itself, since it is already present, but it is our job to integrate it in GOAL in a way that programmers, like the other groups, can make use of this when creating virtual humans.\par 
In this report there is given a overview of the user requirements first. Then a list of the implemented software product is explained in detail. After that, you can find a reflection of the product and process from a software engineering perspective. This is followed by a detailed list of implemented features. A section on the Human Computer Interaction will then explain how the product and users interact. Finally a conclusion and outlook will list all the important findings and future improvements.
\\

\subsection{User requirements}
The user requirements are fully listed in the product planning. Here a brief overview is introduced.\par
The main goal of the project is giving a programmer in GOAL the ability to provide the agents he is creating with emotions. This means that the agents have to express emotions, but can also act based on these emotions. Without a lot of work (it should be very easy) the programmer can define what makes the agent happy and what not. This can be done by setting a configuration file which is provided with a full documentation. Also he can check which emotions are present at a certain moment for a certain agent. This so that he can debug with the emotions and see what results certain settings can cause. Furthermore the programmer can query the emotions in GOAL so that he can program certain logical rules. For example, the programmer queries whether the agent is happy. If he is happy, then he should stop moving and chill out.\par Keep in mind that all the features and settings need to be documented very thoroughly so that programmers can add these emotional features very easily. The focus is on all this being easy. No complicated settings are needed at all (they can be used when demanded) to get emotional agents. All these features are an overview of the requirements this project should fulfill at the end. As mentioned before, a full list of the user requirements in the MoSCoW-form can be found in the product planning.

\clearpage

\section{Overview of the developed and implemented software product}
This section gives an overview of what we implemented in this project. 

\subsection{Emotion configuration}
The emotion configuration is the most important part of our implementation. It is an instance which holds all the gamygdala settings for a GOAL program. This EmotionConfig instance is used in the main GOAL cycle to determine if the emotions of the gamygdala agent should be updated.

\subsection{Parser}
To be able to use the EmotionConfig in GOAL we had to write a parser for the EmotionConfig. The parsing for the goal and mas2g files in GOAL is done by using the parsing tool ANTLR. However, after we made up a syntax for the emotion configuration we thought it would be overly complicated to use ANTLR for this parser.\\
Instead we used a simple implementation where the parser iterates over the lines and reads what setting is configured on that line. While parsing the EmotionConfig instance is updated according to the configured settings. For the goals, subgoals and relations a new object is created to store in the EmotionConfig. 

\subsection{Mentalstate}
We had to implement changes to the mentalstate to be able to create a emotionbase for an agent. With this emotionbase the programmer using goal can easily see what emotions an agent currently has. Before prolog starts reasoning about beliefs it merges all beliefbases for an agent, with the emotionbase (which is a beliefbase) prolog also takes the emotions into account. This way the programmer can use the emotions just as he would use any other belief.

\subsection{SimpleIDE}
We also changed the simpleIDE to make it able to edit the emotion configuration file. This includes changes in the filepanel to let the emo2g files show as a child of the mas2g file, parsing errors and a tab to be able to debug the emotion base. We unfortunately did not have the time to add syntax highlighting for the emotion configuration file or the emotionFile block in the mas2g file. 

\clearpage

\section{Reflection on the product and process from a software engineering perspective}
In this section we will reflect in on our product and our process from a software engineering perspective. We will describe some of the problems we encountered and what we learned from them as well as how things could have been improved. We will start with a look at the product and after that we will look at the process.

\subsection{Product}
We started off with an existing code base (GOAL) on which we had to build. Since the goal was to make working with emotions in the GOAL environment intuitive and similar to working with the existing GOAL language we tried to keep true to the existing architecture. There were four main repositories in which we had to make changes, we will start with the Grammar repository.
The Grammar repository is where we had to add code to give goal programmers the option to use emotions without knowing what exactly is happening while also giving options for programmers to tinker with the emotion settings that are available in the Gamygdala engine. To facilitate this we made a file with configurations. Since we found that it was difficult to use without any knowledge about the Gamydgala engine we made a document to help configuring this file.\par 
In the Runtime repository the emotions had to be handled during runtime. This was done by connecting the adding and dropping of goals to the Gamygdala engine and by making sure that the emotion updates from the Gamydala engine were handled and added to a base similar to how percepts are updated every cycle. We implemented this by adding calls in the existing code to functions that we made to handle the emotions. For the structure of our functions we looked at how the existing code handled similar situations. After some initial time to get to know the existing code base we were able to implement the functionality we wanted in this repository relatively easily. However, when we tried to add to add an EmotionBase rather than use the PerceptBase to process the emotion we learned that this was a lot harder to do. \par 
In the simpleIDE we wanted to be able to show the emotion from the EmotionBase similar to how percepts, messages, and beliefs are shown in their own tab. While we were able to do this the problem was not to make emotions visible in the EmotionBase but rather to get these changes functional in prolog and goal files. Which brings us to the changes in the Mentalstate repository.
To create an EmotionBase we had to make changes to the Mentalstate repository. Since the functionality of the EmotionBase was going to be very similar to that of the PerceptBase the code that we added in this repository was very similar to the already existing code. This repository is also where we had to make sure that the emotion information was inserted into the prolog knowledge base, and while this seemed to be simple enough this is where we ran into troubles with the EmotionBase. \par 
The difficulties with the addition of the EmotionBase mostly seemed to stem from issues with the dependencies between the repositories, and since the existing code base was pretty large this made it difficult to comprehend why it was not working as we intended. This showed that when writing software it is critical to maintain good testing coverage and integration testing, which the existing code lacked. We also learned that when you want to implement new functionality into an existing code base with some hurry, it is best to focus solely on functionality rather than trying to implement it in a “nice” way. Especially if you aren’t sure the code will still work with the “nicer” implementation.

\subsection{Process}
We made use of an incremental and iterative software development process. Every week we made a scrum plan and at the end of the week we reflected on this plan and made a new one. Initially the tasks we made were not very fitting for scrum, they were somewhat too generic and did not lead to something we could demo. We were able to use the feedback given by the TA and the problems we encountered in our weekly scrums to improve our scrum process over the course of the project. \par 
We used git on the social platform Github in combination with TravisCI and Maven for our code versioning and continuous integration. The code bases we used were already on github and after cloning them to our own repositories we later had some troubles with the POM-files which were still referring to the original repositories. This problem came back several times, and we should probably have fixed this initially so any new issues would have been smaller and therefor easier to solve. \par 
Another problem we encountered here was that the original code already failed when doing integration tests, this had to do with the tests trying to open windows which was not possible and to solve this we had to ignore a few tests. Regarding testing, the original code lacked good test coverage and integration testing. Due to the difficulty of integration testing the whole code base including our new code we decided to focus our testing efforts on making unit tests involving the code we added to the existing code. However, the lack of integration tests available often make it hard to find where errors originated.  \par 
The original code also had a ton of Checkstyle errors and a lot of errors from the Maven Javadoc tool. We did not use Checkstyle because the errors were legion and if we used the Maven Javadoc tool the code would not compile. \par
This was also the first project where we made use of a pull-based development model. Initially we made some mistakes by pulling changes in the master onto our own base instead of rebasing. We also learned to squash a lot of small changes into fewer more substantial commits to make it easier to track the changes that were made. 
\clearpage

\section{Interaction Design}
This section will describe how we tried to validate the interaction of our users with our product. First there will be a description of the method used to gain feedback then the results from this will be discussed after which there will be an explanation of how we processed this feedback. Finally there will be a short discussion on what could be done to gain more valuable feedback.

\subsection{Used Method}
The idea used to gain the feedback from users on our product was to ask  the other group that is programming the virtual human in GOAL to complete a tutorial. This is a perfect group to do this with since they will have to work with our program to complete their own, they have experience with GOAL and know a little bit about gamygdala so they're a perfect example of our typical end user. They were asked to think out loud so that it was possible to identify any issues they were having. The recording of this session is attached to this report.

Sadly enough only three people of the other group were available, they worked on the tutorial in one team. This felt like the best set up because that way they talk with each other about what they're doing.

\subsection{Results}
From the feedback gained it became obvious that some of our documentation was not yet clear enough. There were three identifiable issues with the documentation:

\begin{itemize}
	\item  Sometimes small details about how something worked were plain missing.
	\item Sometimes information was not put in a central place. The users were for example not finding some details of how to use the emotion configuration, what they were looking for was mentioned somewhere in the documentation but due to it not being in one central place it was difficult to find.
	
	\item Some things were still plain wrong since they had been changed after the documentation was made.
\end{itemize}

Furthermore we identified one bug in the program when the users were working on the tutorial. 
\subsection{Reaction}
The details that were still missing in the documentation will be added to it and there will be updates to make sure that there are central parts of the documentation to find all relevant information about certain aspects of the program without having to go look at other parts of the documentation. We will also make sure that the wrong documentation is updated to be compliant with the current version of our program. The bug that was identified has since been fixed.

\subsection{Commentary}
The feedback we've gained is somewhat superficial, it was certainly useful feedback but sadly enough the other teams did not have enough time to use the program for an extended period of time and then have an interview with us. Pretty much all of the received feedback was feedback on the documentation, we feel like if they would have had more time to use our program that we would have received more valuable feedback on missing features and the usability of our implemented features.

Only being able to do it with one group also makes the feedback more limited the product should be tested on some more groups to gain more diverse feedback.

\section{Evaluation of the functional modules and the product in its entirety, including the
	failure analysis}
This section is split up in two main subsections. The evaluation of the functional modules and the failure analysis. The evaluation is about how our functionalities were evaluated and in the failure analysis section a list of failures during the process is given.

\subsection{Evaluation}
To evaluate the functional modules this group used the tutorial and the HCI meeting with the other group. In this evaluation is was clear that the main functionalities that were needed were present and working. The other group successfully finished the tutorial and was able to implement their emotional agent with the functionalities provided by us. However, they did not have enough time to use the implementations extensively. This means that the feedback is not very in depth and thus mainly based on small bugs and lack of documentation. You can find the evaluation of the HCI in the dedicated section.

\subsection{Failure analysis}
In this section the major failures that our group encountered will be explained. These involve the problems, how they arose and how they have been fixed or why they were not easily fixed. As the definition of failure states, a failure occurs when the delivered service no longer complies with the specifications.(According to Laprie et al.)\cite{failure}

\subsubsection*{Empty EmotionConfig}
An empty EmotionConfig file caused some default values to be 0 instead their intended default values. The cause of this failure was mainly because of the way the parser used the singleton of the EmotionConfig. When the parser finds no lines an empty EmotionConfig was returned instead of an instance which would automatically set values and return that instance whenever you ask it. This failure was present for a long time but during the tutorial our group found out it was there. It can be defined as a failure since it does not comply with the specifications. An empty EmotionConfig should use the default settings. It was easy to solve this failure. More unittests would have caught this.

\subsubsection*{Agent stuck}
During the implementations of the achievements of goals a certain failure arose. 2 agents were ran with the same GOAL code, but for some reason one of the bots got stuck when performing actions. The problem was synchronization. The lack of integration tests from both GOAL programmers as this group caused this failure to get into the code. It was an easy problem to solve, but the fact that it was present was bad. Our group handled accordingly to this problem by making  more integration tests. 

\subsubsection*{EmotionBase}
Our group specified the requirements that the programmer in GOAL can look at an Emotionbase, just like the beliefbase, and see the emotion present for a certain agent. This feature was harder to implement that expected. Trying to mimic the belief or percept base was not as easy as it seemed. Eventually the emotions were added but could not be querried as intended. This failure was hard to fix and it is not fully working yet. 

\section{Outlook}
This section gives a recommendation as to what possible improvements there still are for future expansion of the project.

\subsection{Emotion configuration parser}
First off we define the properties of the emotion configuration in a regular text file that is parsed by a simple parser. It's not a bad idea to improve upon this and to create a new file with the ANTLR framework that is used for the other files in GOAL as well. Furthermore while our parser does throw errors which mention which line numbers are still incorrect it would be nice if this could be statically checked and displayed in the SimpleIDE or the GOAL plug-in for eclipse.

\subsection{Emotion configuration}
Secondly there are still a few things that could be added to the emotion configuration. It is possible to define common goals and individual goals and it is possible to define that the individual goals only apply to certain agents. However it is not possible to define a notion of teams for the common goals, if a common goal is defined and two agents adopt this goal then it is assumed that they are working together on this goal in some instances it might be useful to have an optional parameter that allows you to define multiple teams for these common goals. However before adding something like this it should also be considered whether this does not complicate the emotion configuration too much for a feature that might not be all that widely used.

\subsection{Aspects of GOAL that influence emotions}
There are still some aspects in GOAL that are not being taken into account for the evaluation of emotions but which could potentially be interesting. For example bots can send messages to each other and bots can also try to reason about the goals and beliefs that other agents are holding. These parts of GOAL have no effect on emotions in the current implementation. An example of how this could affect emotions is that needing to drop a GOAL because of a message given by another agents is less bad than having to drop a GOAL because of your own observations (the idea being that you were notified beforehand and had to waste less time trying to achieve this goal before realizing you couldn't complete it anymore). While we're not sure how this should affect emotions exactly it would be interesting to take a look at what could be done in these areas. Although, again, adding definitions for these things might make the emotion configuration overly complicated for a feature that might not have that big of an effect, this should be considered when thinking of these features. Either a smart way of setting a standard for these messages (so that programmers just have to send the correct message and not worry about any other configuration) or a very easy way of defining them in the emotion configuration should be figured out.

\subsection{Causal agents}
At the moment determining the causal agent of dropping or achieving a goal is fairly simplistic, for individual goals the causal agent is always the agent itself and for common goals it is the agents that first achieved that goal. This does not always reflect the real world and it might be interesting to see what can be done to improve this. Again just like with the other sections it should be carefully thought out so that it does not complicate the use of gamygdala within GOAL too much. For this an potentially interesting solution would be to define a new drop and insert predicate that not only takes the goal/belief to drop/insert as input but that also allows the programmer to enter which agent caused this drop/insert.

\subsection{Code quality}
Finally, in terms of code quality there can always be improvements of course. Some parts of the code would benefit from being re-factored a bit. Most of the code would also benefit from better integration testing, but this is not only a problem in our own code but also in the code of GOAL. In terms of unit testing the code written by our group scores pretty high but throughout the project we noticed a few times that some changes created serious issue in GOAL but none of our tests notified us of this. This was caused by a shortage of integration testing, all the individual components still seemed to work perfectly fine but when combined in certain scenarios they failed and these scenarios were not always tested. As mentioned, this would also be a recommendation to GOAL itself, at one time for example a modification to updating the goal base caused one of our two agents to not perform any actions anymore at all, this was not caught by integration nor unit tests of GOAL.

\clearpage
\printglossaries

\begin{appendices}
	\section{HCI}
	In this appendix you can find a full report on the HCI meeting and all things that happened. Also with this appendix an audio file with a length of 1h16min is included which is a full recording of the tutorial. Here are the notes our group took during the introduction of our implementations.\\
	\\
	"From the start it seems that importing the project is an uncertain problem. For 2 of the 3 members of the group is it not clear what to do with it. One knows what to do and is helping. Cloning from Github directly into Eclipse seems to do weird things. Somehow the project is imported in that way but the folders are not known as source folders thus running Java code is not working. Now they are trying to clone to the harddisk and then import it into Eclipse. This seems to work. Now they mention that converting it to a maven project is not an option when you right click. It is under the tab configuration which is not mentioned clearly in the guide it seems. Now they tell the same thing for maven install. It is under the tab Run As which is somehow unclear for the members of the group. One of them is still in the goal perspective and this is bugging Eclipse. Bernd is helping them now and telling they should better be in the Java perspective instead of the GOAL perspective.\par 
	They have come to the point of running an agent with an empty emotionConfig configuration file. They are running the agent and they look at the current feelings of the agent and say that nothing is present. No emotions are given. They take a look at the mas2g file but it seems to be set correctly. They think it is a bug. It is a bug indeed. We tell them that we will fix this because it should give emotions when an empty file is set. Now they are trying out the whitelist option our group implemented. The information is not that clear. They are arguing what the intention is and what it does. They are not reading the documentation very thoroughly. They have gotten it working and now they ask us how you can make actions alter emotions. They can do this by adding goals to do the actions and then when the action is performed a goal is achieved and an emotion can be given. They are happy with this answer and think it is a good solution. They wonder why emotions like distress are coming. They did not read through all the documentation saying that dropping goals also cast emotions. They are getting a version working and they are excited that their agents get emotions. They wonder now what the isIncremental does. They can find this in the Gamygdala paper but it is a bit unclear that the last parameter(boolean) is about this setting. We will change this. \par Now they have a version working with subgoals. They tried to run with a goal with a congruence of 3. This cannot happen since the congruence must be between -1 and 1. It is mentioned at a certain section but not in the section of the subgoals. Now they have finished the single bot tasks and will see if they can get two bots working together.\par It seems unclear they have to change the masfile to run the second agent with the same GOAL code. After a while our group helped them because this is just a little change in the commands in the mas2g files. Now they want to query an emotion and alter an action. They try to use the gam() predicate but it is not correct. They should use the emo() predicate. This is being mentioned incorrectly in the tutorial. They tell us they will try to let one agent chill out in the Dropzone when he is happy enough. They get this working after a while because first they let him perform an action but the logical rule was not high enough in the calling order so other logical rules are getting called before that one. This is something you should think about when programming in GOAL. They set the relations which works the first time they try it. They reflect on what the did and are done."\\
	\\
	Together with these notes the full audio file can be found here:
	reference
\end{appendices}





\begin{thebibliography}{9}
	
	\bibitem{GOAL}
	GOAL programming language
	\url{http://ii.tudelft.nl/trac/goal}
	
	\bibitem{Gamygdala}
	Gamygdala emotion engine
	\url{http://ii.tudelft.nl/~joostb/gamygdala/index.html}
	
	\bibitem{MoSCoW}
	MoScoW method
	\url{http://en.wikipedia.org/wiki/MoSCoW_method }
	
	\bibitem{Tygron}
	Tygron engine
	\url{http://www.tygron.com }
	
	\bibitem{SimpleIDE}
	Simple IDE
	\url{https://github.com/goalhub/simpleIDE }
	
	\bibitem{failure}
	J. C. Laprie (Ed.).\\ 
	Dependability: Basic Concepts and Terminology. \\
	Springer-Verlag, Wein, New York, 1992.\\
	
	
\end{thebibliography}

\end{document}     
